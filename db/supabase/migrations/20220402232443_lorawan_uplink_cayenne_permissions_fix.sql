-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

-- Removed log messages
CREATE OR REPLACE FUNCTION cayenne.decode(IN packet bytea)
    RETURNS cayenne.reading[]
    LANGUAGE 'plv8'
    STABLE
    PARALLEL SAFE
    COST 100
    
AS $BODY$
let get_map = (key) => {
    let map = plv8.execute('select * from cayenne.map where key=$1', [key]);
    if (map.length === 0) plv8.elog(ERROR, 'Unknown map key: ' + JSON.stringify(key));
    return map[0];
  }
  let get_chan = (key) => {
    let chan = plv8.execute('select * from cayenne.channel where key=$1', [key]);
    if (chan.length === 0) plv8.elog(ERROR, 'Unknown chan key: ' + JSON.stringify(key));
    return chan[0];
  }

  let bytes_to_float = (bytes) => {
    if (bytes.length !== 4) plv8.elog(ERROR, 'Invalid bytes length');
    let f32 = new Float32Array(bytes.buffer);
    return f32[0];
  }

  let bytes_to_u16 = (bytes) => {
    if (bytes.length !== 2) plv8.elog(ERROR, 'Invalid bytes length');
    return (new Uint16Array(bytes.buffer))[0];
  }

  // Only supports FLOAT and U16
  let get_type_size = (t) => t === 'FLOAT' ? 4 : 2;
  let map = null;
  let chan = null;
  let bytes = new Uint8Array(packet);
  let readings = [];
  let i = 0;

  while (i < bytes.length) {
    chan = get_chan(bytes[i]);
    i++;
    if (i >= bytes.length) plv8.elog(ERROR, 'Malformed packet');

    map = get_map(bytes[i]);
    i++;
    if (i >= bytes.length) plv8.elog(ERROR, 'Malformed packet');

    let decode_to = map.decode_to;
    let size = get_type_size(decode_to);
    let data = bytes.slice(i, i + size).reverse();
    let val = decode_to === 'FLOAT' ? bytes_to_float(data) : bytes_to_u16(data);
    readings.push({
      chan: chan.val,
      type: map.val,
      val,
    });
    i += size;
  }

  return readings;
$BODY$;

GRANT REFERENCES, SELECT, TRIGGER ON TABLE cayenne.channel TO anon;

GRANT TRIGGER, REFERENCES, SELECT ON TABLE cayenne.channel TO authenticated;

GRANT ALL ON TABLE cayenne.channel TO postgres;

GRANT ALL ON TABLE cayenne.channel TO service_role;

GRANT TRIGGER, REFERENCES, SELECT ON TABLE cayenne.channel TO PUBLIC;

GRANT REFERENCES, SELECT, TRIGGER ON TABLE cayenne.map TO anon;

GRANT TRIGGER, REFERENCES, SELECT ON TABLE cayenne.map TO authenticated;

GRANT ALL ON TABLE cayenne.map TO postgres;

GRANT ALL ON TABLE cayenne.map TO service_role;

GRANT TRIGGER, REFERENCES, SELECT ON TABLE cayenne.map TO PUBLIC;

CREATE OR REPLACE FUNCTION public.handle_lorawan_uplink(
	req jsonb)
    RETURNS json
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
declare
  payload text;
  dev_eui text;
  uplink_received_at timestamp;
  readings cayenne.reading[];
  rd cayenne.reading;
  row public.reading;
  inserted public.reading[] default '{}';
begin
  payload := req -> 'uplink_message' ->> 'frm_payload';
  dev_eui := req -> 'end_device_ids' ->> 'dev_eui';
  uplink_received_at := req -> 'uplink_message' ->> 'received_at';

  if payload is null then raise exception 'Missing payload'; end if;
  if dev_eui is null then raise exception 'Missing device EUI'; end if;
  if uplink_received_at is null then raise exception 'Missing uplink_received_at'; end if;

  readings = cayenne.decode(decode(payload, 'base64'));

  foreach rd in array readings loop
    select *
    from
    new_reading(
      dev_eui,
      rd.type,
      uplink_received_at,
      rd.val)
    into row;
    inserted := inserted || row;
    raise notice 'row = %', row;
    raise notice 'array = %', inserted;
  end loop;

  if array_length(inserted, 1) > 0 then
    return json_build_object('result', inserted);
  else
    perform set_config('response.status', '500', true);
    return json_build_object('error', 'No readings inserted');
  end if;
end;
$BODY$;

ALTER FUNCTION public.handle_lorawan_uplink(jsonb)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_lorawan_uplink(jsonb) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.handle_lorawan_uplink(jsonb) TO anon;

GRANT EXECUTE ON FUNCTION public.handle_lorawan_uplink(jsonb) TO authenticated;

GRANT EXECUTE ON FUNCTION public.handle_lorawan_uplink(jsonb) TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_lorawan_uplink(jsonb) TO service_role;
