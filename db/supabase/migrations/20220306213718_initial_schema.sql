-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

-- Type: node_loc_method

-- DROP TYPE IF EXISTS public.node_loc_method;

CREATE TYPE public.node_loc_method AS ENUM
    ('MANUAL', 'GPS', 'GW_APPROX');

ALTER TYPE public.node_loc_method
    OWNER TO postgres;


create extension if not exists postgis;

-- Type: lorawan_activation_method

-- DROP TYPE IF EXISTS public.lorawan_activation_method;

CREATE TYPE public.lorawan_activation_method AS ENUM
    ('OTAA', 'ABP');

ALTER TYPE public.lorawan_activation_method
    OWNER TO postgres;

-- Type: device_loc_method

-- DROP TYPE IF EXISTS public.device_loc_method;

CREATE TYPE public.device_loc_method AS ENUM
    ('GW_APPROX', 'MANUAL');

ALTER TYPE public.device_loc_method
    OWNER TO postgres;

-- Type: link_direction

-- DROP TYPE IF EXISTS public.link_direction;

CREATE TYPE public.link_direction AS ENUM
    ('DOWNLINK', 'UPLINK');

ALTER TYPE public.link_direction
    OWNER TO postgres;

-- Type: user_alert_method

-- DROP TYPE IF EXISTS public.user_alert_method;

CREATE TYPE public.user_alert_method AS ENUM
    ('SMS', 'EMAIL');

ALTER TYPE public.user_alert_method
    OWNER TO postgres;

-- Type: gateway_loc_method

-- DROP TYPE IF EXISTS public.gateway_loc_method;

CREATE TYPE public.gateway_loc_method AS ENUM
    ('GPS', 'MANUAL');

ALTER TYPE public.gateway_loc_method
    OWNER TO postgres;
CREATE TABLE IF NOT EXISTS public.profile
(
    profile_id uuid NOT NULL,
    first_name text COLLATE pg_catalog."default" DEFAULT ''::text,
    last_name text COLLATE pg_catalog."default" DEFAULT ''::text,
    CONSTRAINT profile_pkey PRIMARY KEY (profile_id),
    CONSTRAINT profile_profile_id_fkey FOREIGN KEY (profile_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

CREATE TABLE IF NOT EXISTS public.device
(
    device_id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    profile_id uuid NOT NULL,
    name character varying(64) COLLATE pg_catalog."default" NOT NULL,
    dev_eui character(16) COLLATE pg_catalog."default" NOT NULL,
    app_skey character(32) COLLATE pg_catalog."default",
    app_key character(32) COLLATE pg_catalog."default",
    nwk_skey character(32) COLLATE pg_catalog."default",
    app_eui character(16) COLLATE pg_catalog."default",
    activation_method lorawan_activation_method,
    aws_device_id character varying(128) COLLATE pg_catalog."default" NOT NULL,
    bme_config json DEFAULT '{}'::json,
    bme_state json DEFAULT '{}'::json,
    CONSTRAINT device_pkey PRIMARY KEY (device_id),
    CONSTRAINT device_aws_device_id_key UNIQUE (aws_device_id),
    CONSTRAINT device_dev_eui_key UNIQUE (dev_eui),
    CONSTRAINT device_profile_id_fkey FOREIGN KEY (profile_id)
        REFERENCES public.profile (profile_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

CREATE TABLE IF NOT EXISTS public.location
(
    loc_id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    loc_geog geography(Point,4326) NOT NULL,
    CONSTRAINT location_pkey PRIMARY KEY (loc_id)
)

TABLESPACE pg_default;

CREATE TABLE IF NOT EXISTS public.device_meta
(
    device_id integer NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    loc_id integer,
    loc_updated_at timestamp with time zone,
    loc_method device_loc_method,
    loc_accuracy real,
    last_uplink_at timestamp with time zone,
    last_downlink_at timestamp with time zone,
    CONSTRAINT device_meta_pkey PRIMARY KEY (device_id),
    CONSTRAINT device_meta_device_id_fkey FOREIGN KEY (device_id)
        REFERENCES public.device (device_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT device_meta_loc_id_fkey FOREIGN KEY (loc_id)
        REFERENCES public.location (loc_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

CREATE TABLE IF NOT EXISTS public.sensor_chan
(
    sensor_chan_id smallint NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 32767 CACHE 1 ),
    name character varying(64) COLLATE pg_catalog."default",
    units character varying(16) COLLATE pg_catalog."default",
    CONSTRAINT sensor_chan_pkey PRIMARY KEY (sensor_chan_id),
    CONSTRAINT sensor_chan_name_key UNIQUE (name),
    CONSTRAINT sensor_chan_name_check CHECK (upper(name::text) = name::text)
)

TABLESPACE pg_default;

CREATE TABLE IF NOT EXISTS public.reading
(
    reading_id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    device_id integer NOT NULL,
    loc_id integer NOT NULL,
    sensor_chan_id smallint NOT NULL,
    taken_at timestamp with time zone NOT NULL,
    received_at timestamp with time zone DEFAULT now(),
    val double precision NOT NULL,
    CONSTRAINT reading_pkey PRIMARY KEY (reading_id),
    CONSTRAINT reading_device_id_fkey FOREIGN KEY (device_id)
        REFERENCES public.device (device_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT reading_loc_id_fkey FOREIGN KEY (loc_id)
        REFERENCES public.location (loc_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT reading_sensor_chan_id_fkey FOREIGN KEY (sensor_chan_id)
        REFERENCES public.sensor_chan (sensor_chan_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

CREATE TABLE IF NOT EXISTS public.gateway
(
    gateway_id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    profile_id uuid NOT NULL,
    name character varying(64) COLLATE pg_catalog."default" NOT NULL,
    aws_gateway_id character varying(128) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT gateway_pkey PRIMARY KEY (gateway_id),
    CONSTRAINT gateway_aws_gateway_id_key UNIQUE (aws_gateway_id),
    CONSTRAINT gateway_profile_id_fkey FOREIGN KEY (profile_id)
        REFERENCES public.profile (profile_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

CREATE TABLE IF NOT EXISTS public.gateway_meta
(
    gateway_id integer NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    loc_id integer,
    loc_updated_at timestamp with time zone,
    loc_method gateway_loc_method,
    loc_accuracy real,
    last_uplink_at timestamp with time zone,
    last_downlink_at timestamp with time zone,
    CONSTRAINT gateway_meta_pkey PRIMARY KEY (gateway_id),
    CONSTRAINT gateway_meta_gateway_id_fkey FOREIGN KEY (gateway_id)
        REFERENCES public.gateway (gateway_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT gateway_meta_loc_id_fkey FOREIGN KEY (loc_id)
        REFERENCES public.location (loc_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

CREATE OR REPLACE FUNCTION public.get_device_location(
	id integer)
    RETURNS location
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
select *
from location
where loc_id = (
  select loc_id
  from device_meta
  where device_meta.device_id = id
);
$BODY$;

ALTER FUNCTION public.get_device_location(integer)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.get_device_location(integer) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_device_location(integer) TO anon;

GRANT EXECUTE ON FUNCTION public.get_device_location(integer) TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_device_location(integer) TO postgres;

GRANT EXECUTE ON FUNCTION public.get_device_location(integer) TO service_role;

CREATE OR REPLACE FUNCTION public.get_device_owner(
	req_device_id integer)
    RETURNS uuid
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
select profile_id
from device
where device_id = req_device_id
$BODY$;

ALTER FUNCTION public.get_device_owner(integer)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.get_device_owner(integer) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_device_owner(integer) TO anon;

GRANT EXECUTE ON FUNCTION public.get_device_owner(integer) TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_device_owner(integer) TO postgres;

GRANT EXECUTE ON FUNCTION public.get_device_owner(integer) TO service_role;

CREATE OR REPLACE FUNCTION public.get_gateway_owner(
	req_gateway_id integer)
    RETURNS uuid
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
begin
  return (
    select profile_id
    from gateway
    where gateway_id = req_gateway_id
  );
end;
$BODY$;

ALTER FUNCTION public.get_gateway_owner(integer)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.get_gateway_owner(integer) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_gateway_owner(integer) TO anon;

GRANT EXECUTE ON FUNCTION public.get_gateway_owner(integer) TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_gateway_owner(integer) TO postgres;

GRANT EXECUTE ON FUNCTION public.get_gateway_owner(integer) TO service_role;

CREATE OR REPLACE FUNCTION public.device_by_deveui(
	lookup_dev_eui text)
    RETURNS device
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
select *
from device
where device.dev_eui = lookup_dev_eui;
$BODY$;

CREATE OR REPLACE FUNCTION public.new_reading(
	dev_eui text,
	sensor_channel text,
	at timestamp with time zone,
	value double precision)
    RETURNS reading
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
with dev as (select * from device_by_deveui(dev_eui))
insert
into reading (device_id, loc_id, sensor_chan_id, taken_at, received_at, val)
values ((select device_id from dev),
        (select loc_id from get_device_location((select device_id from dev))),
        (select sensor_chan_id from sensor_chan where sensor_chan.name = sensor_channel),
        at,
        now(),
        value)
returning *;
$BODY$;

ALTER FUNCTION public.new_reading(text, text, timestamp with time zone, double precision)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.new_reading(text, text, timestamp with time zone, double precision) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.new_reading(text, text, timestamp with time zone, double precision) TO anon;

GRANT EXECUTE ON FUNCTION public.new_reading(text, text, timestamp with time zone, double precision) TO authenticated;

GRANT EXECUTE ON FUNCTION public.new_reading(text, text, timestamp with time zone, double precision) TO postgres;

GRANT EXECUTE ON FUNCTION public.new_reading(text, text, timestamp with time zone, double precision) TO service_role;

-- Type: reading_w_loc

-- DROP TYPE IF EXISTS public.reading_w_loc;

CREATE TYPE public.reading_w_loc AS
(
	reading_id integer,
	device_id integer,
	taken_at timestamp with time zone,
	received_at timestamp with time zone,
	val double precision,
	geog geography(Point,4326),
	chan character varying(64),
	units character varying(16)
);

ALTER TYPE public.reading_w_loc
    OWNER TO postgres;

CREATE OR REPLACE VIEW public.reading_by_chan
 AS
 SELECT reading.reading_id,
    reading.device_id,
    location.loc_geog AS geog,
    reading.taken_at,
    reading.received_at,
    reading.val,
    sensor_chan.name AS chan_name,
    sensor_chan.units AS chan_units
   FROM reading
     JOIN sensor_chan ON reading.sensor_chan_id = sensor_chan.sensor_chan_id
     JOIN location ON reading.loc_id = location.loc_id;

ALTER TABLE public.reading_by_chan
    OWNER TO postgres;

CREATE OR REPLACE FUNCTION public.readings_within(
	start_at timestamp with time zone DEFAULT '-infinity'::timestamp with time zone,
	end_at timestamp with time zone DEFAULT 'infinity'::timestamp with time zone,
	center_lon double precision DEFAULT 0.0,
	center_lat double precision DEFAULT 0.0,
	radius double precision DEFAULT 'Infinity'::double precision,
	chan text DEFAULT ''::text)
    RETURNS SETOF reading_w_loc 
    LANGUAGE 'sql'
    COST 100
    STABLE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
select r.reading_id,
       r.device_id,
       r.taken_at,
       r.received_at,
       r.val,
       r.geog,
       r.chan_name,
       r.chan_units
from reading_by_chan r
where start_at <= r.taken_at
  and end_at >= r.taken_at
  and st_dwithin(r.geog, st_makepoint(center_lon, center_lat), radius)
  and case when chan != '' then r.chan_name = chan else true end
order by r.taken_at;
$BODY$;

ALTER FUNCTION public.readings_within(timestamp with time zone, timestamp with time zone, double precision, double precision, double precision, text)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.readings_within(timestamp with time zone, timestamp with time zone, double precision, double precision, double precision, text) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.readings_within(timestamp with time zone, timestamp with time zone, double precision, double precision, double precision, text) TO anon;

GRANT EXECUTE ON FUNCTION public.readings_within(timestamp with time zone, timestamp with time zone, double precision, double precision, double precision, text) TO authenticated;

GRANT EXECUTE ON FUNCTION public.readings_within(timestamp with time zone, timestamp with time zone, double precision, double precision, double precision, text) TO postgres;

GRANT EXECUTE ON FUNCTION public.readings_within(timestamp with time zone, timestamp with time zone, double precision, double precision, double precision, text) TO service_role;

CREATE OR REPLACE FUNCTION public.random_time(
	last_days integer)
    RETURNS timestamp with time zone
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
select now() + (interval '1 minute' * 1440 * last_days * random());
$BODY$;

ALTER FUNCTION public.random_time(integer)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.random_time(integer) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.random_time(integer) TO anon;

GRANT EXECUTE ON FUNCTION public.random_time(integer) TO authenticated;

GRANT EXECUTE ON FUNCTION public.random_time(integer) TO postgres;

GRANT EXECUTE ON FUNCTION public.random_time(integer) TO service_role;

CREATE OR REPLACE FUNCTION public.generate_eui(
	)
    RETURNS text
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
SELECT array_to_string(
           array(select substr('ABCDEF0123456789', ((random() * (16 - 1) + 1)::integer), 1)
                 from generate_series(1, 16)), '');
$BODY$;

ALTER FUNCTION public.generate_eui()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.generate_eui() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.generate_eui() TO anon;

GRANT EXECUTE ON FUNCTION public.generate_eui() TO authenticated;

GRANT EXECUTE ON FUNCTION public.generate_eui() TO postgres;

GRANT EXECUTE ON FUNCTION public.generate_eui() TO service_role;


ALTER FUNCTION public.device_by_deveui(text)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.device_by_deveui(text) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.device_by_deveui(text) TO anon;

GRANT EXECUTE ON FUNCTION public.device_by_deveui(text) TO authenticated;

GRANT EXECUTE ON FUNCTION public.device_by_deveui(text) TO postgres;

GRANT EXECUTE ON FUNCTION public.device_by_deveui(text) TO service_role;

CREATE OR REPLACE FUNCTION public.generate_random_point(
	lat double precision,
	lng double precision,
	radius double precision)
    RETURNS geography
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
select st_makepoint(
             lat + random() * radius,
             lng + random() * radius
         );
$BODY$;

CREATE OR REPLACE FUNCTION public.generate_random_location(
	lat double precision,
	lng double precision,
	radius double precision)
    RETURNS integer
    LANGUAGE 'sql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
insert into location (loc_geog)
values (generate_random_point(lat, lng, radius))
returning loc_id;
$BODY$;

ALTER FUNCTION public.generate_random_location(double precision, double precision, double precision)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.generate_random_location(double precision, double precision, double precision) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.generate_random_location(double precision, double precision, double precision) TO anon;

GRANT EXECUTE ON FUNCTION public.generate_random_location(double precision, double precision, double precision) TO authenticated;

GRANT EXECUTE ON FUNCTION public.generate_random_location(double precision, double precision, double precision) TO postgres;

GRANT EXECUTE ON FUNCTION public.generate_random_location(double precision, double precision, double precision) TO service_role;


ALTER FUNCTION public.generate_random_point(double precision, double precision, double precision)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.generate_random_point(double precision, double precision, double precision) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.generate_random_point(double precision, double precision, double precision) TO anon;

GRANT EXECUTE ON FUNCTION public.generate_random_point(double precision, double precision, double precision) TO authenticated;

GRANT EXECUTE ON FUNCTION public.generate_random_point(double precision, double precision, double precision) TO postgres;

GRANT EXECUTE ON FUNCTION public.generate_random_point(double precision, double precision, double precision) TO service_role;

CREATE OR REPLACE FUNCTION public.handle_new_user()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF SECURITY DEFINER
    SET search_path=public
AS $BODY$
begin
  insert into profile (profile_id)
  values (new.id);
  return new;
end;
$BODY$;

ALTER FUNCTION public.handle_new_user()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO authenticated;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO anon;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO service_role;

CREATE OR REPLACE FUNCTION public.update_loc_updated_at()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
begin
  new.loc_updated_at := current_timestamp;
  return new;
end;
$BODY$;

ALTER FUNCTION public.update_loc_updated_at()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.update_loc_updated_at() TO authenticated;

GRANT EXECUTE ON FUNCTION public.update_loc_updated_at() TO postgres;

GRANT EXECUTE ON FUNCTION public.update_loc_updated_at() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.update_loc_updated_at() TO anon;

GRANT EXECUTE ON FUNCTION public.update_loc_updated_at() TO service_role;

CREATE OR REPLACE FUNCTION public.create_device_meta_trigger()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
begin
  insert into device_meta (device_id) values (new.device_id);
  return null;
end;
$BODY$;

ALTER FUNCTION public.create_device_meta_trigger()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.create_device_meta_trigger() TO authenticated;

GRANT EXECUTE ON FUNCTION public.create_device_meta_trigger() TO postgres;

GRANT EXECUTE ON FUNCTION public.create_device_meta_trigger() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.create_device_meta_trigger() TO anon;

GRANT EXECUTE ON FUNCTION public.create_device_meta_trigger() TO service_role;

CREATE OR REPLACE FUNCTION public.create_gateway_meta_trigger()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
begin
  insert into gateway_meta (gateway_id) values (new.gateway_id);
  return null;
end;
$BODY$;

ALTER FUNCTION public.create_gateway_meta_trigger()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.create_gateway_meta_trigger() TO authenticated;

GRANT EXECUTE ON FUNCTION public.create_gateway_meta_trigger() TO postgres;

GRANT EXECUTE ON FUNCTION public.create_gateway_meta_trigger() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.create_gateway_meta_trigger() TO anon;

GRANT EXECUTE ON FUNCTION public.create_gateway_meta_trigger() TO service_role;

CREATE OR REPLACE FUNCTION public.updated_at_trigger()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
begin
  new.updated_at := current_timestamp;
  return new;
end;
$BODY$;

ALTER FUNCTION public.updated_at_trigger()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.updated_at_trigger() TO authenticated;

GRANT EXECUTE ON FUNCTION public.updated_at_trigger() TO postgres;

GRANT EXECUTE ON FUNCTION public.updated_at_trigger() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.updated_at_trigger() TO anon;

GRANT EXECUTE ON FUNCTION public.updated_at_trigger() TO service_role;

CREATE TABLE IF NOT EXISTS public.event
(
    id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    profile_id uuid,
    "time" timestamp with time zone DEFAULT now(),
    raw_event json,
    CONSTRAINT event_pkey PRIMARY KEY (id),
    CONSTRAINT event_profile_id_fkey FOREIGN KEY (profile_id)
        REFERENCES public.profile (profile_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.event
    OWNER to postgres;

ALTER TABLE IF EXISTS public.event
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.event TO anon;

GRANT ALL ON TABLE public.event TO authenticated;

GRANT ALL ON TABLE public.event TO postgres;

GRANT ALL ON TABLE public.event TO service_role;
CREATE POLICY "Users can see their own events"
    ON public.event
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() = profile_id));


ALTER TABLE IF EXISTS public.reading
    OWNER to postgres;

ALTER TABLE IF EXISTS public.reading
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.reading TO anon;

GRANT ALL ON TABLE public.reading TO authenticated;

GRANT ALL ON TABLE public.reading TO postgres;

GRANT ALL ON TABLE public.reading TO service_role;
CREATE INDEX IF NOT EXISTS reading_device_id
    ON public.reading USING btree
    (device_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS reading_taken_at
    ON public.reading USING btree
    (taken_at ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS sensor_chan_id
    ON public.reading USING btree
    (sensor_chan_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Allow unauthenticated reads"
    ON public.reading
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);


ALTER TABLE IF EXISTS public.gateway_meta
    OWNER to postgres;

ALTER TABLE IF EXISTS public.gateway_meta
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.gateway_meta TO anon;

GRANT ALL ON TABLE public.gateway_meta TO authenticated;

GRANT ALL ON TABLE public.gateway_meta TO postgres;

GRANT ALL ON TABLE public.gateway_meta TO service_role;
CREATE POLICY "Only owners can use their own gateway metadata"
    ON public.gateway_meta
    AS PERMISSIVE
    FOR ALL
    TO public
    USING ((get_gateway_owner(gateway_id) = auth.uid()));

CREATE TRIGGER gateway_meta_loc_updated_at_trigger
    BEFORE UPDATE 
    ON public.gateway_meta
    FOR EACH ROW
    WHEN (old.loc_id IS DISTINCT FROM new.loc_id)
    EXECUTE FUNCTION public.update_loc_updated_at();

CREATE TRIGGER gateway_meta_updated_at
    BEFORE UPDATE 
    ON public.gateway_meta
    FOR EACH ROW
    EXECUTE FUNCTION public.updated_at_trigger();


ALTER TABLE IF EXISTS public.sensor_chan
    OWNER to postgres;

ALTER TABLE IF EXISTS public.sensor_chan
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.sensor_chan TO anon;

GRANT ALL ON TABLE public.sensor_chan TO authenticated;

GRANT ALL ON TABLE public.sensor_chan TO postgres;

GRANT ALL ON TABLE public.sensor_chan TO service_role;
CREATE POLICY "Only admins can update sensor_chan"
    ON public.sensor_chan
    AS PERMISSIVE
    FOR ALL
    TO public
    USING (false);

CREATE TABLE IF NOT EXISTS public.node_event
(
    -- Inherited from table public.event: id integer NOT NULL,
    -- Inherited from table public.event: profile_id uuid,
    -- Inherited from table public.event: "time" timestamp with time zone DEFAULT now(),
    -- Inherited from table public.event: raw_event json,
    device_id integer,
    gateway_id integer,
    link_dir link_direction,
    device_rf_meta json,
    gateway_rf_meta json,
    loc_id integer,
    loc_method node_loc_method,
    reading_id integer,
    CONSTRAINT node_event_device_id_fkey FOREIGN KEY (device_id)
        REFERENCES public.device (device_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT node_event_gateway_id_fkey FOREIGN KEY (gateway_id)
        REFERENCES public.gateway (gateway_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT node_event_loc_id_fkey FOREIGN KEY (loc_id)
        REFERENCES public.location (loc_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT node_event_reading_id_fkey FOREIGN KEY (reading_id)
        REFERENCES public.reading (reading_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)
    INHERITS (public.event)
TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.node_event
    OWNER to postgres;

ALTER TABLE IF EXISTS public.node_event
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.node_event TO anon;

GRANT ALL ON TABLE public.node_event TO authenticated;

GRANT ALL ON TABLE public.node_event TO postgres;

GRANT ALL ON TABLE public.node_event TO service_role;
CREATE POLICY "Users can see their own node events"
    ON public.node_event
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() = profile_id));

CREATE TABLE IF NOT EXISTS public.alert_def
(
    alert_def_id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    profile_id uuid NOT NULL,
    sensor_chan_id smallint,
    trigger_val double precision,
    alert_method user_alert_method,
    alert_to character varying(96) COLLATE pg_catalog."default",
    CONSTRAINT alert_def_pkey PRIMARY KEY (alert_def_id),
    CONSTRAINT alert_def_profile_id_fkey FOREIGN KEY (profile_id)
        REFERENCES public.profile (profile_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT alert_def_sensor_chan_id_fkey FOREIGN KEY (sensor_chan_id)
        REFERENCES public.sensor_chan (sensor_chan_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

CREATE TABLE IF NOT EXISTS public.alert_event
(
    -- Inherited from table public.event: id integer NOT NULL,
    -- Inherited from table public.event: profile_id uuid,
    -- Inherited from table public.event: "time" timestamp with time zone DEFAULT now(),
    -- Inherited from table public.event: raw_event json,
    reading_id integer,
    alert_def_id integer,
    CONSTRAINT alert_event_alert_def_id_fkey FOREIGN KEY (alert_def_id)
        REFERENCES public.alert_def (alert_def_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT alert_event_reading_id_fkey FOREIGN KEY (reading_id)
        REFERENCES public.reading (reading_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)
    INHERITS (public.event)
TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.alert_event
    OWNER to postgres;

GRANT ALL ON TABLE public.alert_event TO anon;

GRANT ALL ON TABLE public.alert_event TO authenticated;

GRANT ALL ON TABLE public.alert_event TO postgres;

GRANT ALL ON TABLE public.alert_event TO service_role;
CREATE POLICY "Users can see their own alert events"
    ON public.alert_event
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() = profile_id));


ALTER TABLE IF EXISTS public.alert_def
    OWNER to postgres;

ALTER TABLE IF EXISTS public.alert_def
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.alert_def TO anon;

GRANT ALL ON TABLE public.alert_def TO authenticated;

GRANT ALL ON TABLE public.alert_def TO postgres;

GRANT ALL ON TABLE public.alert_def TO service_role;
CREATE INDEX IF NOT EXISTS alert_def_profile_id
    ON public.alert_def USING btree
    (profile_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS alert_def_sensor_chan_id
    ON public.alert_def USING btree
    (sensor_chan_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Only users can use their own alerts"
    ON public.alert_def
    AS PERMISSIVE
    FOR ALL
    TO public
    USING ((auth.uid() = profile_id));


ALTER TABLE IF EXISTS public.location
    OWNER to postgres;

ALTER TABLE IF EXISTS public.location
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.location TO anon;

GRANT ALL ON TABLE public.location TO authenticated;

GRANT ALL ON TABLE public.location TO postgres;

GRANT ALL ON TABLE public.location TO service_role;
CREATE INDEX IF NOT EXISTS location_gist
    ON public.location USING gist
    (loc_geog)
    TABLESPACE pg_default;
CREATE POLICY "Anyone can insert locations"
    ON public.location
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK (true);
CREATE POLICY "Anyone can read locations"
    ON public.location
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);


ALTER TABLE IF EXISTS public.device_meta
    OWNER to postgres;

ALTER TABLE IF EXISTS public.device_meta
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.device_meta TO anon;

GRANT ALL ON TABLE public.device_meta TO authenticated;

GRANT ALL ON TABLE public.device_meta TO postgres;

GRANT ALL ON TABLE public.device_meta TO service_role;
CREATE POLICY "Only owners can use their own device metadata"
    ON public.device_meta
    AS PERMISSIVE
    FOR ALL
    TO public
    USING ((get_device_owner(device_id) = auth.uid()));
CREATE POLICY "Users can modify their own device's config"
    ON public.device_meta
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = get_device_owner(device_id)));
CREATE POLICY "Users can read their own device's config"
    ON public.device_meta
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() = get_device_owner(device_id)));

CREATE TRIGGER device_meta_loc_updated_at_trigger
    BEFORE UPDATE 
    ON public.device_meta
    FOR EACH ROW
    WHEN (old.loc_id IS DISTINCT FROM new.loc_id)
    EXECUTE FUNCTION public.update_loc_updated_at();

CREATE TRIGGER device_meta_updated_at
    BEFORE UPDATE 
    ON public.device_meta
    FOR EACH ROW
    EXECUTE FUNCTION public.updated_at_trigger();


ALTER TABLE IF EXISTS public.device
    OWNER to postgres;

ALTER TABLE IF EXISTS public.device
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.device TO anon;

GRANT ALL ON TABLE public.device TO authenticated;

GRANT ALL ON TABLE public.device TO postgres;

GRANT ALL ON TABLE public.device TO service_role;
CREATE INDEX IF NOT EXISTS device_deveui
    ON public.device USING btree
    (dev_eui COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS device_profile_id
    ON public.device USING btree
    (profile_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Only owners can use their own devices"
    ON public.device
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((profile_id = auth.uid()));

CREATE TRIGGER device_insert_create_meta_trigger
    AFTER INSERT
    ON public.device
    FOR EACH ROW
    EXECUTE FUNCTION public.create_device_meta_trigger();


ALTER TABLE IF EXISTS public.gateway
    OWNER to postgres;

ALTER TABLE IF EXISTS public.gateway
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.gateway TO anon;

GRANT ALL ON TABLE public.gateway TO authenticated;

GRANT ALL ON TABLE public.gateway TO postgres;

GRANT ALL ON TABLE public.gateway TO service_role;
CREATE INDEX IF NOT EXISTS gateway_profile_id
    ON public.gateway USING btree
    (profile_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Only owners can use their own gateways"
    ON public.gateway
    AS PERMISSIVE
    FOR ALL
    TO public
    USING ((get_gateway_owner(gateway_id) = auth.uid()));

CREATE TRIGGER gateway_insert_create_meta_trigger
    AFTER INSERT
    ON public.gateway
    FOR EACH ROW
    EXECUTE FUNCTION public.create_gateway_meta_trigger();


ALTER TABLE IF EXISTS public.profile
    OWNER to postgres;

ALTER TABLE IF EXISTS public.profile
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.profile TO anon;

GRANT ALL ON TABLE public.profile TO authenticated;

GRANT ALL ON TABLE public.profile TO postgres;

GRANT ALL ON TABLE public.profile TO service_role;
CREATE POLICY "Only the account holder can update their profile"
    ON public.profile
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = profile_id));
CREATE POLICY "Only the account holder can view their profile"
    ON public.profile
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() = profile_id));




GRANT ALL ON TABLE public.reading_by_chan TO authenticated;
GRANT ALL ON TABLE public.reading_by_chan TO postgres;
GRANT ALL ON TABLE public.reading_by_chan TO anon;
GRANT ALL ON TABLE public.reading_by_chan TO service_role;
